"use client";

import { ANIMATION_DURATION, COLORS, EXTERNAL_URLS, GLOBE_CONFIG } from "@/constants/globe";
import { GLOBE_SIZE_LIMITS, VIEWPORT_DEFAULTS, ZOOM_LEVELS } from "@/constants/zoomLevels";
import { useHtmlElements } from "@/hooks/useHtmlElements";
import { createGlobeImageUrl } from "@/utils/globeImageGenerator";
import { createZoomPreventListeners, getISOCode, getPolygonColor, getPolygonLabel } from "@/utils/globeUtils";
import type { GlobeInstance } from "globe.gl";
import dynamic from "next/dynamic";
import type React from "react";
import { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useRef, useState } from "react";
import type { ReactGlobeProps } from "../../types/globe";
import { renderHtmlElement } from "./htmlElementRenderer";

const Globe = dynamic(() => import("react-globe.gl"), {
  ssr: false,
});

export interface ReactGlobeRef {
  globeRef: React.RefObject<any>;
}

const ReactGlobe = forwardRef<ReactGlobeRef, ReactGlobeProps>(
  (
    {
      travelPatterns,
      currentGlobeIndex,
      selectedCountry,
      onCountrySelect,
      onZoomChange,
      onClusterSelect,
      clusteredData,
      zoomLevel,
      selectedClusterData,
      snapZoomTo,
    },
    ref,
  ) => {
    const globeRef = useRef<GlobeInstance | null>(null);
    const activeCountryFlagRef = useRef<string | null>(null);
    const [activeCountryFlag, setActiveCountryFlag] = useState<string | null>(null);
    const [activeCountryItemIdList, setActiveCountryItemIdList] = useState<string[] | null>(null);
    const [countries, setCountries] = useState<any[]>([]);
    const [globeLoading, setGlobeLoading] = useState(true);
    const [globeError, setGlobeError] = useState<string | null>(null);
    const [windowSize, setWindowSize] = useState({
      width: typeof window !== "undefined" ? window.innerWidth : VIEWPORT_DEFAULTS.WIDTH,
      height: typeof window !== "undefined" ? window.innerHeight : VIEWPORT_DEFAULTS.HEIGHT,
    });
    const currentPattern = travelPatterns[currentGlobeIndex];

    // Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïóê globeRef ÎÖ∏Ï∂ú
    useImperativeHandle(ref, () => ({
      globeRef,
    }));

    // Figma ÎîîÏûêÏù∏ÏóêÏÑú ÏßÄÍµ¨Î≥∏ Í∑∏ÎùºÎîîÏñ∏Ìä∏ ÌÖçÏä§Ï≤ò ÏÉùÏÑ±
    const globeImageUrl = useMemo(() => createGlobeImageUrl(), []);
    const [displayPhase, setDisplayPhase] = useState<"root" | "country" | "city">("root");
    const [isAnimating, setIsAnimating] = useState(false);
    const phaseTargetRef = useRef<"root" | "country" | "city" | null>(null);
    const prevZoomRef = useRef<number | null>(null);

    // ISO ÏΩîÎìú Îß§Ìïë Ìï®Ïàò
    const getISOCodeMapped = useCallback(getISOCode, []);

    // Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    useEffect(() => {
      const loadCountries = async () => {
        try {
          setGlobeLoading(true);
          setGlobeError(null);

          const response = await fetch(EXTERNAL_URLS.WORLD_GEOJSON);

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const countriesData = await response.json();
          const features = countriesData?.features || [];

          setCountries(features);
          setGlobeLoading(false);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          setGlobeError(`Íµ≠Í∞Ä Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: ${errorMessage}`);
          setGlobeLoading(false);
          setCountries([]);
        }
      };

      loadCountries();
    }, []);

    // Ìè¥Î¶¨Í≥§ ÏÉâÏÉÅ Í≥ÑÏÇ∞ Ìï®Ïàò
    const getPolygonColorMapped = useCallback(
      (feature: any) => getPolygonColor(feature, currentPattern.countries, getISOCodeMapped),
      [currentPattern.countries, getISOCodeMapped],
    );

    // Ìè¥Î¶¨Í≥§ Î†àÏù¥Î∏î Ìï®Ïàò
    const getPolygonLabelMapped = useCallback(
      (feature: any) => getPolygonLabel(feature, currentPattern.countries, getISOCodeMapped),
      [currentPattern.countries, getISOCodeMapped],
    );

    // Ìè¥Î¶¨Í≥§ ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
    const handlePolygonClick = useCallback(
      (polygon: any) => {
        const countryISOCode = polygon.properties?.ISO_A3 || polygon.id;
        const clickedCountry = currentPattern.countries.find((c: any) => getISOCodeMapped(c.id) === countryISOCode);
        if (clickedCountry) {
          onCountrySelect(clickedCountry.id);

          // ÏÑ†ÌÉùÎêú Íµ≠Í∞ÄÎ°ú Ïπ¥Î©îÎùº Ïù¥Îèô
          if (globeRef.current) {
            globeRef.current.pointOfView(
              {
                lat: clickedCountry.lat,
                lng: clickedCountry.lng,
                altitude: 1.5,
              },
              1000,
            );
          }
        }
      },
      [currentPattern.countries, getISOCodeMapped, onCountrySelect],
    );

    // HTML ÏöîÏÜå Îç∞Ïù¥ÌÑ∞
    const htmlElements = useHtmlElements({
      isAnimating,
      displayPhase,
      phaseTargetRef,
      prevZoomRef,
      zoomLevel,
      selectedClusterData: selectedClusterData || null,
      clusteredData,
      currentPatternCountries: currentPattern.countries,
    });

    // HTML ÏöîÏÜå Î†åÎçîÎßÅ Ìï®Ïàò
    const getHtmlElement = useCallback(
      (d: any) => {
        return renderHtmlElement({
          d,
          htmlElements,
          zoomLevel,
          globeRef,
          displayPhase,
          isAnimating,
          phaseTargetRef,
          setActiveCountryFlag,
          activeCountryFlagRef,
          setActiveCountryItemIdList,
          setDisplayPhase,
          setIsAnimating,
          onClusterSelect,
          onZoomChange,
          onCountrySelect,
        });
      },
      [htmlElements, zoomLevel, displayPhase, isAnimating, onClusterSelect, onZoomChange, onCountrySelect],
    );

    // Ï§å Î≥ÄÍ≤Ω Í∞êÏßÄ
    const handleZoomChange = useCallback(
      (pov: any) => {
        if (pov && typeof pov.altitude === "number") {
          let newZoom = pov.altitude;

          if (newZoom < GLOBE_CONFIG.MIN_ZOOM) {
            newZoom = GLOBE_CONFIG.MIN_ZOOM;
            if (globeRef.current) {
              globeRef.current.pointOfView({ altitude: GLOBE_CONFIG.MIN_ZOOM }, 0);
            }
          } else if (newZoom > GLOBE_CONFIG.MAX_ZOOM) {
            newZoom = GLOBE_CONFIG.MAX_ZOOM;
            if (globeRef.current) {
              globeRef.current.pointOfView({ altitude: GLOBE_CONFIG.MAX_ZOOM }, 0);
            }
          }

          // Ïô∏Î∂ÄÏóêÏÑú Ïä§ÎÉÖ ÏßÄÏãúÍ∞Ä ÏûàÏúºÎ©¥ Ìï¥Îãπ Í∞íÏúºÎ°ú Í≥†Ï†ï
          if (typeof snapZoomTo === "number") {
            newZoom = snapZoomTo;
            if (globeRef.current) {
              globeRef.current.pointOfView({ altitude: newZoom }, 0);
            }
          }

          // Ï§å ÏïÑÏõÉ Ïãú Îã®Í≥ÑÎ≥Ñ Î∑∞ Î≥ÄÍ≤Ω Î∞è ÏÑ†ÌÉù Ï¥àÍ∏∞Ìôî
          if (!isAnimating && displayPhase === "city" && newZoom > ZOOM_LEVELS.RENDERING.CITY_TO_COUNTRY) {
            setDisplayPhase("country");
          }
          if (!isAnimating && newZoom > ZOOM_LEVELS.RENDERING.COUNTRY_TO_ROOT) {
            setDisplayPhase("root");
          }
          if (!isAnimating && newZoom > ZOOM_LEVELS.RENDERING.COUNTRY_MIN) {
            setActiveCountryItemIdList(null);
            setActiveCountryFlag(null);
            activeCountryFlagRef.current = null;
          }

          // ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Î•º ÏúÑÌïú Ïù¥Ï†Ñ Í∞í Ï†ÄÏû•
          prevZoomRef.current = newZoom;
          onZoomChange(newZoom);
        }
      },
      [onZoomChange, snapZoomTo, displayPhase, isAnimating],
    );

    // ÏúàÎèÑÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à Í∞êÏßÄ
    useEffect(() => {
      if (typeof window === "undefined") return;

      const handleResize = () => {
        setWindowSize({
          width: window.innerWidth,
          height: window.innerHeight,
        });
      };

      window.addEventListener("resize", handleResize);
      return () => window.removeEventListener("resize", handleResize);
    }, []);

    // Î∏åÎùºÏö∞Ï†Ä Ï§å Î∞©ÏßÄ Î∞è Globe Ï¥àÍ∏∞ ÏÑ§Ï†ï
    useEffect(() => {
      if (typeof window === "undefined") return;

      const timer = setTimeout(() => {
        if (globeRef.current && !globeLoading) {
          globeRef.current.pointOfView({ altitude: GLOBE_CONFIG.INITIAL_ALTITUDE }, ANIMATION_DURATION.INITIAL_SETUP);

          if (globeRef.current.controls) {
            globeRef.current.controls().minDistance = GLOBE_CONFIG.MIN_DISTANCE;
            globeRef.current.controls().maxDistance = GLOBE_CONFIG.MAX_DISTANCE;
          }
        }
      }, ANIMATION_DURATION.SETUP_DELAY);

      const { preventZoom, preventKeyboardZoom, preventTouchZoom } = createZoomPreventListeners();

      document.addEventListener("wheel", preventZoom, { passive: false });
      document.addEventListener("keydown", preventKeyboardZoom);
      document.addEventListener("touchstart", preventTouchZoom, {
        passive: false,
      });

      return () => {
        document.removeEventListener("wheel", preventZoom);
        document.removeEventListener("keydown", preventKeyboardZoom);
        document.removeEventListener("touchstart", preventTouchZoom);
        clearTimeout(timer);
      };
    }, [globeLoading]);

    // Ï¥àÍ∏∞ ÏãúÏ†ê ÏÑ§Ï†ï (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑúÎßå)
    useEffect(() => {
      if (!globeRef.current || globeLoading || countries.length === 0) return;

      // ÏßÄÍµ¨Î≥∏Ïù¥ ÏôÑÏ†ÑÌûà Î°úÎìúÎêú ÌõÑ Ï¥àÍ∏∞ ÏãúÏ†ê ÏÑ§Ï†ï
      setTimeout(() => {
        if (globeRef.current && typeof window !== "undefined") {
          globeRef.current.pointOfView({
            altitude: GLOBE_CONFIG.INITIAL_ALTITUDE,
          });
        }
      }, ANIMATION_DURATION.SETUP_DELAY);
    }, [globeLoading, countries]);

    if (globeLoading) {
      return <div className="text-text-secondary text-sm">üåç ÏßÄÍµ¨Î≥∏ Î°úÎî© Ï§ë...</div>;
    }

    if (globeError) {
      return (
        <div
          style={{
            width: GLOBE_CONFIG.WIDTH,
            height: GLOBE_CONFIG.HEIGHT,
            borderRadius: "50%",
            background: "radial-gradient(circle at 30% 30%, #2c3e50 0%, #1a252f 100%)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: "white",
            fontSize: "14px",
            textAlign: "center",
            flexDirection: "column",
            gap: "10px",
          }}
        >
          <div>‚ö†Ô∏è ÏßÄÍµ¨Î≥∏ Î°úÎî© Ïã§Ìå®</div>
          <div style={{ fontSize: "12px", opacity: 0.8 }}>Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî</div>
        </div>
      );
    }

    return (
      <Globe
        ref={globeRef}
        width={Math.min(GLOBE_SIZE_LIMITS.MAX_WIDTH, windowSize.width)}
        height={Math.min(GLOBE_SIZE_LIMITS.MAX_WIDTH, windowSize.width)}
        backgroundColor="rgba(0,0,0,0)"
        globeImageUrl={globeImageUrl}
        showAtmosphere={true}
        atmosphereColor={COLORS.ATMOSPHERE}
        atmosphereAltitude={GLOBE_CONFIG.ATMOSPHERE_ALTITUDE}
        polygonsData={countries}
        polygonCapColor={getPolygonColorMapped}
        polygonSideColor={() => COLORS.POLYGON_SIDE}
        polygonStrokeColor={() => COLORS.POLYGON_STROKE}
        polygonAltitude={GLOBE_CONFIG.POLYGON_ALTITUDE}
        polygonLabel={getPolygonLabelMapped}
        onPolygonClick={handlePolygonClick}
        htmlElementsData={htmlElements}
        htmlElement={getHtmlElement}
        htmlAltitude={() => 0}
        enablePointerInteraction={true}
        onZoom={handleZoomChange}
      />
    );
  },
);

ReactGlobe.displayName = "ReactGlobe";

export default ReactGlobe;
